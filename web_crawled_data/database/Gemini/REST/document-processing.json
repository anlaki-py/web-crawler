{
    "base_url": "https://ai.google.dev/gemini-api/docs/document-processing?lang=rest",
    "crawl_date": "2025-01-01T18:51:49.653994",
    "chunk_number": 1,
    "pages": [
        {
            "url": "https://ai.google.dev/gemini-api/docs/document-processing?lang=rest",
            "title": "Explore document processing capabilities with the Gemini API  |  Google AI for Developers",
            "text_content": "Explore document processing capabilities with the Gemini API  |  Google AI for Developers Models Solutions Build with Gemini Gemini API Google AI Studio Customize Gemma open models Gemma open models Multi-framework with Keras Fine-tune in Colab Run on-device Google AI Edge Gemini Nano on Android Chrome built-in web APIs Build responsibly Responsible GenAI Toolkit Secure AI Framework Code assistance Android Studio Chrome DevTools Colab Firebase Google Cloud JetBrains Jules Project IDX VS Code Showcase Gemini Showcase Gemini API Developer Competition Community Google AI Forum Gemini for Research / English Deutsch Español – América Latina Français Indonesia Italiano Polski Português – Brasil Shqip Tiếng Việt Türkçe Русский עברית العربيّة فارسی हिंदी বাংলা ภาษาไทย 中文 – 简体 中文 – 繁體 日本語 한국어 Sign in Gemini API docs API Reference SDKs Pricing Cookbook Models Gemini API docs API Reference SDKs Pricing Cookbook Solutions More Code assistance More Showcase More Community More Overview Get started Quickstart API keys Libraries Release notes Developer forum Models Gemini Gemini 2.0 Overview SDKs Thinking Mode Experimental models Capabilities Text generation Vision Audio understanding Long context Code execution Structured output Function calling Intro to function calling Function calling tutorial Extract structured data Document understanding Grounding Grounding with Google Search Use Google Search Suggestions Fine-tuning Intro to fine-tuning Fine-tuning tutorial Embeddings Guides Context caching Image generation Prompt engineering Intro to prompting Prompting strategies File prompting strategies Token counting OpenAI compatibility Billing info Safety Safety settings Safety guidance Additional resources Android (on-device) Firebase extensions Generative models Google AI Studio quickstart LearnLM Migrate to Cloud OAuth authentication Semantic retrieval System instructions Gemini for Research Gemini Academic Program Use cases Applications Code assistant Flutter code generator Content search Data exploration agent Writing assistant Slides reviewer Troubleshooting API troubleshooting AI Studio troubleshooting Google Workspace Request more quota Legal Terms of service Available regions Abuse monitoring Build with Gemini Gemini API Google AI Studio Customize Gemma open models Gemma open models Multi-framework with Keras Fine-tune in Colab Run on-device Google AI Edge Gemini Nano on Android Chrome built-in web APIs Build responsibly Responsible GenAI Toolkit Secure AI Framework Android Studio Chrome DevTools Colab Firebase Google Cloud JetBrains Jules Project IDX VS Code Gemini Showcase Gemini API Developer Competition Google AI Forum Gemini for Research Gemini 2.0 Flash Experimental is now available! Learn more Home Gemini API Models Send feedback Explore document processing capabilities with the Gemini API Python Node.js Go REST The Gemini API supports PDF input, including long documents (up to 3600 pages).\nGemini models process PDFs with native vision, and are therefore able to\nunderstand both text and image contents inside documents. With native PDF vision\nsupport, Gemini models are able to: Analyze diagrams, charts, and tables inside documents. Extract information into structured output formats. Answer questions about visual and text contents in documents. Summarize documents. Transcribe document content (e.g. to HTML) preserving layouts and formatting, for use in downstream applications (such as in RAG pipelines). This tutorial demonstrates some possible ways to use the Gemini API with PDF\ndocuments. All output is text-only. Before you begin: Set up your project and API key Before calling the Gemini API, you need to set up your project and configure\nyour API key. Expand to view how to set up your project and API key Tip: For complete setup instructions, see the Gemini API quickstart . Get and secure your API key You need an API key to call the Gemini API. If you don't already have one,\ncreate a key in Google AI Studio. Get an API key It's strongly recommended that you do not check an API key into your version\ncontrol system. This tutorial assumes that you're accessing your API key as an environment\nvariable. Prompting with PDFs This guide demonstrates how to upload and process PDFs\nusing the File API or by including them as inline data. Technical details Gemini 1.5 Pro and 1.5 Flash support a maximum of 3,600 document pages. Document\npages must be in one of the following text data MIME types: PDF - application/pdf JavaScript - application/x-javascript , text/javascript Python - application/x-python , text/x-python TXT - text/plain HTML - text/html CSS - text/css Markdown - text/md CSV - text/csv XML - text/xml RTF - text/rtf Each document page is equivalent to 258 tokens. While there are no specific limits to the number of pixels in a document besides\nthe model's context window, larger pages are scaled down to a maximum resolution\nof 3072x3072 while preserving their original aspect ratio, while smaller pages\nare scaled up to 768x768 pixels. There is no cost reduction for pages at lower\nsizes, other than bandwidth, or performance improvement for pages at higher\nresolution. For best results: Rotate pages to the correct orientation before uploading. Avoid blurry pages. If using a single page, place the text prompt after the page. PDF input For PDF payloads under 20MB, you can choose between uploading base64\nencoded documents or directly uploading locally stored files. Base64 encoded documents You can process PDF documents directly from URLs. Here's a code snippet\nshowing how to do this: DOC_URL = \"https://discovery.ucl.ac.uk/id/eprint/10089234/1/343019_3_art_0_py4t4l_convrt.pdf\" PROMPT = \"Summarize this document\" DISPLAY_NAME = \"base64_pdf\" # Download the PDF wget -O \" ${ DISPLAY_NAME } .pdf\" \" ${ DOC_URL } \" # Check for FreeBSD base64 and set flags accordingly if [[ \" $( base64 --version 2>&1 ) \" = * \"FreeBSD\" * ]] ; then B64FLAGS = \"--input\" else B64FLAGS = \"-w0\" fi # Base64 encode the PDF ENCODED_PDF = $( base64 $B64FLAGS \" ${ DISPLAY_NAME } .pdf\" ) # Generate content using the base64 encoded PDF curl \"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -X POST \\ -d '{ \"contents\": [{ \"parts\":[ {\"inline_data\": {\"mime_type\": \"application/pdf\", \"data\": \"' \" $ENCODED_PDF \" '\"}}, {\"text\": \"' $PROMPT '\"} ] }] }' 2 > /dev/null > response.json\n\ncat response.json echo jq \".candidates[].content.parts[].text\" response.json # Clean up the downloaded PDF rm \" ${ DISPLAY_NAME } .pdf\" Large PDFs You can use the File API to upload a document of any size. Always use the File\nAPI when the total request size (including the files, text prompt, system\ninstructions, etc.) is larger than 20 MB. Note: The File API lets you store up to 20 GB of files per project, with a\nper-file maximum size of 2 GB. Files are stored for 48 hours. They can be\naccessed in that period with your API key, but cannot be downloaded from the\nAPI. The File API is available at no cost in all regions where the Gemini API is\navailable. Call media.upload to upload a file using the\nFile API. The following code uploads a document file and then uses the file in a\ncall to models.generateContent . Large PDFs from URLs Use the File API for large PDF files available from URLs,\nsimplifying the process of uploading and processing these documents directly\nthrough their URLs: PDF_PATH = \"https://www.nasa.gov/wp-content/uploads/static/history/alsj/a17/A17_FlightPlan.pdf\" DISPLAY_NAME = \"A17_FlightPlan\" PROMPT = \"Summarize this document\" # Download the PDF from the provided URL wget -O \" ${ DISPLAY_NAME } .pdf\" \" ${ PDF_PATH } \" MIME_TYPE = $( file -b --mime-type \" ${ DISPLAY_NAME } .pdf\" ) NUM_BYTES = $( wc -c < \" ${ DISPLAY_NAME } .pdf\" ) echo \"MIME_TYPE: ${ MIME_TYPE } \" echo \"NUM_BYTES: ${ NUM_BYTES } \" tmp_header_file = upload-header.tmp # Initial resumable request defining metadata. # The upload url is in the response headers dump them to a file. curl \" ${ BASE_URL } /upload/v1beta/files?key= ${ GOOGLE_API_KEY } \" \\ -D upload-header.tmp \\ -H \"X-Goog-Upload-Protocol: resumable\" \\ -H \"X-Goog-Upload-Command: start\" \\ -H \"X-Goog-Upload-Header-Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Header-Content-Type: ${ MIME_TYPE } \" \\ -H \"Content-Type: application/json\" \\ -d \"{'file': {'display_name': ' ${ DISPLAY_NAME } '}}\" 2 > /dev/null upload_url = $( grep -i \"x-goog-upload-url: \" \" ${ tmp_header_file } \" | cut -d \" \" -f2 | tr -d \"\\r\" ) rm \" ${ tmp_header_file } \" # Upload the actual bytes. curl \" ${ upload_url } \" \\ -H \"Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Offset: 0\" \\ -H \"X-Goog-Upload-Command: upload, finalize\" \\ --data-binary \"@ ${ DISPLAY_NAME } .pdf\" 2 > /dev/null > file_info.json file_uri = $( jq \".file.uri\" file_info.json ) echo \"file_uri: ${ file_uri } \" # Now generate content using that file curl \"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -X POST \\ -d '{ \"contents\": [{ \"parts\":[ {\"text\": \"' $PROMPT '\"}, {\"file_data\":{\"mime_type\": \"application/pdf\", \"file_uri\": ' $file_uri '}}] }] }' 2 > /dev/null > response.json\n\ncat response.json echo jq \".candidates[].content.parts[].text\" response.json # Clean up the downloaded PDF rm \" ${ DISPLAY_NAME } .pdf\" Large PDFs stored locally NUM_BYTES = $( wc -c < \" ${ PDF_PATH } \" ) DISPLAY_NAME = TEXT tmp_header_file = upload-header.tmp # Initial resumable request defining metadata. # The upload url is in the response headers dump them to a file. curl \" ${ BASE_URL } /upload/v1beta/files?key= ${ GOOGLE_API_KEY } \" \\ -D upload-header.tmp \\ -H \"X-Goog-Upload-Protocol: resumable\" \\ -H \"X-Goog-Upload-Command: start\" \\ -H \"X-Goog-Upload-Header-Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Header-Content-Type: application/pdf\" \\ -H \"Content-Type: application/json\" \\ -d \"{'file': {'display_name': ' ${ DISPLAY_NAME } '}}\" 2 > /dev/null upload_url = $( grep -i \"x-goog-upload-url: \" \" ${ tmp_header_file } \" | cut -d \" \" -f2 | tr -d \"\\r\" ) rm \" ${ tmp_header_file } \" # Upload the actual bytes. curl \" ${ upload_url } \" \\ -H \"Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Offset: 0\" \\ -H \"X-Goog-Upload-Command: upload, finalize\" \\ --data-binary \"@ ${ PDF_PATH } \" 2 > /dev/null > file_info.json file_uri = $( jq \".file.uri\" file_info.json ) echo file_uri = $file_uri # Now generate content using that file curl \"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -X POST \\ -d '{ \"contents\": [{ \"parts\":[ {\"text\": \"Can you add a few more lines to this poem?\"}, {\"file_data\":{\"mime_type\": \"application/pdf\", \"file_uri\": ' $file_uri '}}] }] }' 2 > /dev/null > response.json\n\ncat response.json echo jq \".candidates[].content.parts[].text\" response.json files.sh You can verify the API successfully stored the uploaded file and get its\nmetadata by calling files.get . Only the name (and by extension, the uri ) are unique. name = $( jq \".file.name\" file_info.json ) # Get the file of interest to check state curl https://generativelanguage.googleapis.com/v1beta/files/ $name > file_info.json # Print some information about the file you got name = $( jq \".file.name\" file_info.json ) echo name = $name file_uri = $( jq \".file.uri\" file_info.json ) echo file_uri = $file_uri files .sh Multiple PDFs The Gemini API is capable of processing multiple PDF documents in a single\nrequest, as long as the combined size of the documents and the text prompt\nstays within the model's context window. DOC_URL_1 = \"https://arxiv.org/pdf/2312.11805\" DOC_URL_2 = \"https://arxiv.org/pdf/2403.05530\" DISPLAY_NAME_1 = \"Gemini_paper\" DISPLAY_NAME_2 = \"Gemini_1.5_paper\" PROMPT = \"What is the difference between each of the main benchmarks between these two papers? Output these in a table.\" # Function to download and upload a PDF upload_pdf () { local doc_url = \" $1 \" local display_name = \" $2 \" # Download the PDF wget -O \" ${ display_name } .pdf\" \" ${ doc_url } \" local MIME_TYPE = $( file -b --mime-type \" ${ display_name } .pdf\" ) local NUM_BYTES = $( wc -c < \" ${ display_name } .pdf\" ) echo \"MIME_TYPE: ${ MIME_TYPE } \" echo \"NUM_BYTES: ${ NUM_BYTES } \" local tmp_header_file = upload-header.tmp # Initial resumable request curl \" ${ BASE_URL } /upload/v1beta/files?key= ${ GOOGLE_API_KEY } \" \\ -D \" ${ tmp_header_file } \" \\ -H \"X-Goog-Upload-Protocol: resumable\" \\ -H \"X-Goog-Upload-Command: start\" \\ -H \"X-Goog-Upload-Header-Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Header-Content-Type: ${ MIME_TYPE } \" \\ -H \"Content-Type: application/json\" \\ -d \"{'file': {'display_name': ' ${ display_name } '}}\" 2 > /dev/null local upload_url = $( grep -i \"x-goog-upload-url: \" \" ${ tmp_header_file } \" | cut -d \" \" -f2 | tr -d \"\\r\" ) rm \" ${ tmp_header_file } \" # Upload the PDF curl \" ${ upload_url } \" \\ -H \"Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Offset: 0\" \\ -H \"X-Goog-Upload-Command: upload, finalize\" \\ --data-binary \"@ ${ display_name } .pdf\" 2 > /dev/null > \"file_info_ ${ display_name } .json\" local file_uri = $( jq \".file.uri\" \"file_info_ ${ display_name } .json\" ) echo \"file_uri for ${ display_name } : ${ file_uri } \" # Clean up the downloaded PDF rm \" ${ display_name } .pdf\" echo \" ${ file_uri } \" } # Upload the first PDF file_uri_1 = $( upload_pdf \" ${ DOC_URL_1 } \" \" ${ DISPLAY_NAME_1 } \" ) # Upload the second PDF file_uri_2 = $( upload_pdf \" ${ DOC_URL_2 } \" \" ${ DISPLAY_NAME_2 } \" ) # Now generate content using both files curl \"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -X POST \\ -d '{ \"contents\": [{ \"parts\":[ {\"file_data\": {\"mime_type\": \"application/pdf\", \"file_uri\": ' $file_uri_1 '}}, {\"file_data\": {\"mime_type\": \"application/pdf\", \"file_uri\": ' $file_uri_2 '}}, {\"text\": \"' $PROMPT '\"} ] }] }' 2 > /dev/null > response.json\n\ncat response.json echo jq \".candidates[].content.parts[].text\" response.json List files You can list all files uploaded using the File API and their URIs using files.list . echo \"My files: \" curl \"https://generativelanguage.googleapis.com/v1beta/files?key= $GOOGLE_API_KEY \" files.sh Delete files Files uploaded using the File API are automatically deleted after 2 days. You\ncan also manually delete them using files.delete . curl --request \"DELETE\" https://generativelanguage.googleapis.com/v1beta/files/ $name ?key = $GOOGLE_API_KEY files .sh Context caching with PDFs DOC_URL = \"https://www.nasa.gov/wp-content/uploads/static/history/alsj/a17/A17_FlightPlan.pdf\" DISPLAY_NAME = \"A17_FlightPlan\" SYSTEM_INSTRUCTION = \"You are an expert at analyzing transcripts.\" PROMPT = \"Please summarize this transcript\" MODEL = \"models/gemini-1.5-flash-002\" # Make sure this model supports caching TTL = \"300s\" # Or your preferred TTL # Download the PDF wget -O \" ${ DISPLAY_NAME } .pdf\" \" ${ DOC_URL } \" MIME_TYPE = $( file -b --mime-type \" ${ DISPLAY_NAME } .pdf\" ) NUM_BYTES = $( wc -c < \" ${ DISPLAY_NAME } .pdf\" ) echo \"MIME_TYPE: ${ MIME_TYPE } \" echo \"NUM_BYTES: ${ NUM_BYTES } \" tmp_header_file = upload-header.tmp # Initial resumable request defining metadata. # The upload url is in the response headers dump them to a file. curl \" ${ BASE_URL } /upload/v1beta/files?key= ${ GOOGLE_API_KEY } \" \\ -D upload-header.tmp \\ -H \"X-Goog-Upload-Protocol: resumable\" \\ -H \"X-Goog-Upload-Command: start\" \\ -H \"X-Goog-Upload-Header-Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Header-Content-Type: ${ MIME_TYPE } \" \\ -H \"Content-Type: application/json\" \\ -d \"{'file': {'display_name': ' ${ DISPLAY_NAME } '}}\" 2 > /dev/null upload_url = $( grep -i \"x-goog-upload-url: \" \" ${ tmp_header_file } \" | cut -d \" \" -f2 | tr -d \"\\r\" ) rm \" ${ tmp_header_file } \" # Upload the actual bytes. curl \" ${ upload_url } \" \\ -H \"Content-Length: ${ NUM_BYTES } \" \\ -H \"X-Goog-Upload-Offset: 0\" \\ -H \"X-Goog-Upload-Command: upload, finalize\" \\ --data-binary \"@ ${ DISPLAY_NAME } .pdf\" 2 > /dev/null > file_info.json file_uri = $( jq \".file.uri\" file_info.json ) echo \"file_uri: ${ file_uri } \" # Clean up the downloaded PDF rm \" ${ DISPLAY_NAME } .pdf\" # Create the cached content request echo '{ \"model\": \"' $MODEL '\", \"contents\":[ { \"parts\":[ {\"file_data\": {\"mime_type\": \"' $MIME_TYPE '\", \"file_uri\": ' $file_uri '}} ], \"role\": \"user\" } ], \"system_instruction\": { \"parts\": [ { \"text\": \"' $SYSTEM_INSTRUCTION '\" } ], \"role\": \"system\" }, \"ttl\": \"' $TTL '\" }' > request.json # Send the cached content request curl -X POST \" ${ BASE_URL } /v1beta/cachedContents?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -d @request.json \\ > cache.json CACHE_NAME = $( cat cache.json | grep '\"name\":' | cut -d '\"' -f 4 | head -n 1 ) echo \"CACHE_NAME: ${ CACHE_NAME } \" # Send the generateContent request using the cached content curl -X POST \" ${ BASE_URL } / ${ MODEL } :generateContent?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -d '{ \"contents\": [ { \"parts\":[{ \"text\": \"' $PROMPT '\" }], \"role\": \"user\" } ], \"cachedContent\": \"' $CACHE_NAME '\" }' > response.json\n\ncat response.json echo jq \".candidates[].content.parts[].text\" response.json List caches It's not possible to retrieve or view cached content, but you can retrieve\ncache metadata ( name , model , display_name , usage_metadata , create_time , update_time , and expire_time ). To list metadata for all uploaded caches, use CachedContent.list() : curl \"https://generativelanguage.googleapis.com/v1beta/cachedContents?key= $GOOGLE_API_KEY \" cache.sh Update a cache You can set a new ttl or expire_time for a cache. Changing anything else\nabout the cache isn't supported. curl -X PATCH \"https://generativelanguage.googleapis.com/v1beta/ $CACHE_NAME ?key= $GOOGLE_API_KEY \" \\ -H 'Content-Type: application/json' \\ -d '{\"ttl\": \"600s\"}' cache.sh Delete a cache The caching service provides a delete operation for manually removing content\nfrom the cache. curl -X DELETE \"https://generativelanguage.googleapis.com/v1beta/ $CACHE_NAME ?key= $GOOGLE_API_KEY \" cache.sh What's next This guide shows how to use generateContent and\nto generate text outputs from processed documents. To learn more,\nsee the following resources: File prompting strategies : The\nGemini API supports prompting with text, image, audio, and video data, also\nknown as multimodal prompting. System instructions : System\ninstructions let you steer the behavior of the model based on your specific\nneeds and use cases. Safety guidance : Sometimes generative AI\nmodels produce unexpected outputs, such as outputs that are inaccurate,\nbiased, or offensive. Post-processing and human evaluation are essential to\nlimit the risk of harm from such outputs. Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License , and code samples are licensed under the Apache 2.0 License . For details, see the Google Developers Site Policies . Java is a registered trademark of Oracle and/or its affiliates. Last updated 2024-12-20 UTC. Terms Privacy Manage cookies English Deutsch Español – América Latina Français Indonesia Italiano Polski Português – Brasil Shqip Tiếng Việt Türkçe Русский עברית العربيّة فارسی हिंदी বাংলা ภาษาไทย 中文 – 简体 中文 – 繁體 日本語 한국어",
            "meta_description": "Learn how to use the Gemini API to process documents like PDFs",
            "links": [
                "https://ai.google.dev/gemini-api/docs/document-processing"
            ],
            "timestamp": "2025-01-01T18:51:48.839803",
            "status_code": 200
        },
        {
            "url": "https://ai.google.dev/gemini-api/docs/document-processing",
            "title": "Explore document processing capabilities with the Gemini API  |  Google AI for Developers",
            "text_content": "Explore document processing capabilities with the Gemini API  |  Google AI for Developers Models Solutions Build with Gemini Gemini API Google AI Studio Customize Gemma open models Gemma open models Multi-framework with Keras Fine-tune in Colab Run on-device Google AI Edge Gemini Nano on Android Chrome built-in web APIs Build responsibly Responsible GenAI Toolkit Secure AI Framework Code assistance Android Studio Chrome DevTools Colab Firebase Google Cloud JetBrains Jules Project IDX VS Code Showcase Gemini Showcase Gemini API Developer Competition Community Google AI Forum Gemini for Research / English Deutsch Español – América Latina Français Indonesia Italiano Polski Português – Brasil Shqip Tiếng Việt Türkçe Русский עברית العربيّة فارسی हिंदी বাংলা ภาษาไทย 中文 – 简体 中文 – 繁體 日本語 한국어 Sign in Gemini API docs API Reference SDKs Pricing Cookbook Models Gemini API docs API Reference SDKs Pricing Cookbook Solutions More Code assistance More Showcase More Community More Overview Get started Quickstart API keys Libraries Release notes Developer forum Models Gemini Gemini 2.0 Overview SDKs Thinking Mode Experimental models Capabilities Text generation Vision Audio understanding Long context Code execution Structured output Function calling Intro to function calling Function calling tutorial Extract structured data Document understanding Grounding Grounding with Google Search Use Google Search Suggestions Fine-tuning Intro to fine-tuning Fine-tuning tutorial Embeddings Guides Context caching Image generation Prompt engineering Intro to prompting Prompting strategies File prompting strategies Token counting OpenAI compatibility Billing info Safety Safety settings Safety guidance Additional resources Android (on-device) Firebase extensions Generative models Google AI Studio quickstart LearnLM Migrate to Cloud OAuth authentication Semantic retrieval System instructions Gemini for Research Gemini Academic Program Use cases Applications Code assistant Flutter code generator Content search Data exploration agent Writing assistant Slides reviewer Troubleshooting API troubleshooting AI Studio troubleshooting Google Workspace Request more quota Legal Terms of service Available regions Abuse monitoring Build with Gemini Gemini API Google AI Studio Customize Gemma open models Gemma open models Multi-framework with Keras Fine-tune in Colab Run on-device Google AI Edge Gemini Nano on Android Chrome built-in web APIs Build responsibly Responsible GenAI Toolkit Secure AI Framework Android Studio Chrome DevTools Colab Firebase Google Cloud JetBrains Jules Project IDX VS Code Gemini Showcase Gemini API Developer Competition Google AI Forum Gemini for Research Gemini 2.0 Flash Experimental is now available! Learn more Home Gemini API Models Send feedback Explore document processing capabilities with the Gemini API Python Node.js Go REST The Gemini API supports PDF input, including long documents (up to 3600 pages).\nGemini models process PDFs with native vision, and are therefore able to\nunderstand both text and image contents inside documents. With native PDF vision\nsupport, Gemini models are able to: Analyze diagrams, charts, and tables inside documents. Extract information into structured output formats. Answer questions about visual and text contents in documents. Summarize documents. Transcribe document content (e.g. to HTML) preserving layouts and formatting, for use in downstream applications (such as in RAG pipelines). This tutorial demonstrates some possible ways to use the Gemini API with PDF\ndocuments. All output is text-only. What's next This guide shows how to use generateContent and\nto generate text outputs from processed documents. To learn more,\nsee the following resources: File prompting strategies : The\nGemini API supports prompting with text, image, audio, and video data, also\nknown as multimodal prompting. System instructions : System\ninstructions let you steer the behavior of the model based on your specific\nneeds and use cases. Safety guidance : Sometimes generative AI\nmodels produce unexpected outputs, such as outputs that are inaccurate,\nbiased, or offensive. Post-processing and human evaluation are essential to\nlimit the risk of harm from such outputs. Send feedback Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License , and code samples are licensed under the Apache 2.0 License . For details, see the Google Developers Site Policies . Java is a registered trademark of Oracle and/or its affiliates. Last updated 2024-12-20 UTC. Terms Privacy Manage cookies English Deutsch Español – América Latina Français Indonesia Italiano Polski Português – Brasil Shqip Tiếng Việt Türkçe Русский עברית العربيّة فارسی हिंदी বাংলা ภาษาไทย 中文 – 简体 中文 – 繁體 日本語 한국어",
            "meta_description": "Learn how to use the Gemini API to process documents like PDFs",
            "links": [
                "https://ai.google.dev/gemini-api/docs/document-processing",
                "https://ai.google.dev/gemini-api/docs/document-processing",
                "https://ai.google.dev/gemini-api/docs/document-processing",
                "https://ai.google.dev/gemini-api/docs/document-processing",
                "https://ai.google.dev/gemini-api/docs/document-processing",
                "https://ai.google.dev/gemini-api/docs/document-processing"
            ],
            "timestamp": "2025-01-01T18:51:49.641206",
            "status_code": 200
        }
    ]
}